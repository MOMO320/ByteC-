#include <iostream>

int function()
{
	int a = 2;

	return a;
}

int& function1()
{
	int a = 2;
	return a;
}

// 외부 변수의 레퍼런스를 리턴하는 함수
int& function2(int& a)
{
	a = 5;
	return a;
}

// 참조자가 아닌 값을 리턴하는 함수를 참조자로 받기
int function3()
{
	int a = 5;
	return a;
}

int main()
{
	// function 안에 정의된 a 라는 변수의 값이 b에 복사 되었습니다.
	// 여기서 중요한 부분은 복사가 되었다는 것 입니다.
	// function 이 종료되고 나면 a는 메모리에서 사라지게 됩니다.
	// 따라서 더 이상 main 안에서는 a를 만날 수 없습니다.
	int b = function();

	/*
		현재 내 디버깅 환경에서는 디버깅됨 - 어째서?

		아래와 같이 참조자 함수를 리턴하게 되면 문제가 됩니다.
		 
		** 그 이유는 function1안에 정의 되어 있는 a가 함수의 리턴과 함께 사라진다는 점입니다.

		 아래의 문장은 사실상
		 ----------------------------
		 int& ref = a;

		 // 근데 a가 사라짐
		 int b = ref;
		 ----------------------------

		 function이 레퍼런스를 리턴하면서 원래 참조하고 있던 변수가 이미 사라져 버렸으므로 오류가 발생하게 됩니다.
		 쉽게 말해 본체는 이미 사라졌지만 별명만 남아 있는 상황 입니다.

		 이와 같이 레퍼런스는 있는데 원래 참조 하던 것이 사라진 레퍼런스를 댕글링 레퍼런스(Dangling reference)
		 라고 부릅니다.

		 Dangling이란 단어의 원래 뜻은 약하게 결합대서 달랑달랑 거리는 것을 뜻하는데,
		 레퍼런스가 참조해야 할 변수가 사라져서 혼자서 덩그러니 남아 있는 상황과 유사하다고 보면 됩니더ㅏ.

	*/
	int c = function1();

	int x = 2;
	int y = function2(x);	// 인자로 받은 레퍼런스를 그대로 리턴 하고 있습니다.
	 
	std::cout << &x << std::endl;  //0000003E7A51F934
	std::cout << &y << std::endl;  //0000003E7A51F954 (주소 값을 복사 함)

	/*
	  function2(x)를 실행한 시점에서 a는 main의  x 를 참조 하고 있게 됩니다.
	  따라서 function2를 리턴한 참조자는 아직 살아있는 변수인 x를 계속 참조 하게 됩니다.

	  레퍼런스로 리턴을 하게 된다면 레퍼런스가 참조하는 타입의 크기와 상관 없이 딱 한 번의 주소값
	  복사로 전달이 끝나게 됩니다. 

	  메모리 낭비가 되지 않아 좋습니다.(메모리가 큰 변수를 전체 복사하게 될 경우 메모리 낭비가 심하기 때문에
	  위와 같은 방법이 훨씬 효율이 좋습니다.)
	*/
	std::cout << y << std::endl;

	/*
	  ◇ 참조자가 아닌 값을 리턴하는 함수를 참조자로 받기

	  아래와 같이 선언하면 오류가 발생 합니다.

	  오류 : 레퍼런스가 function 함수의 리턴값을 참조할 수 없다는 의미 오류 발생

	  ▶ p가 function의 리턴값을 참조 할 수 없는 이유
	  : 함수의 리턴값은 해당 문장이 끝난 후 바로 사라지는 값이기 때문에 참조자를 만들게 되면 
	    바로 다음에 댕글링 레퍼런스가 되버리기 때문입니다.
	*/

	// int& p = function3();  // 상수가 아니라고 오류 발생

	/* 예외 규칙 
	
	   똑같이 function() 함수의 return 값을 참조자로 받았어도 오류가 발생 하지 않습니다.
	   그 이유는 const(상수) 참조자로 받았기 때문입니다.

	   원칙상 함수의 리턴값은 해당 문장이 끝나면 소멸되는 것이 정상입니다.
	   따라서 기존에 int& 로 받았을 때에는 컴파일 자체가 안되었습니다.
	   하지만 예외 적으로 '상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장됩니다.'
	   그리고 그 연장되는 기간은 레퍼런스가 사라질 때 까지 입니다.
		
	*/

	const int& p = function();
	std::cout << " p : " << p << std::endl;

	return 0;
}