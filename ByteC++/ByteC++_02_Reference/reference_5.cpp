#include <iostream>

/* ◆ 레퍼런스의 배열과 배열의 레퍼런스 
   : 먼저 레퍼런스의 배열이 과연 가능한 것인지에 대해 부터 생각해 봅시다.
     앞서 말했듯이 레퍼런스는 반드시 정의와 함께 초기화를 해주어야 한다고 했습니다.
     따라서 아래와 같이 레퍼런스의 배열을 정의하는 것을 떠올렸을 겁니다.

     int a,b;
     int& arr[2] = {a,b};

     레퍼런스의 배열을 불법(illegal) 이라고 합니다.
     C++ 표준안을 보면 "레퍼런스의 레퍼런스, 레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다." 
     고 규정에 나와있습니다.

*/ 

int main5()
{
    int a, b;
    /*
        아래의 코드의 내용을 해석하면 arr[0]은 a를 의미하고 arr[1]은 b를 의미하고 있습니다.
        이와 같은 생각을 하기 전에 먼저 C++ 상에서 배열이 어떤 식으로 처리되는지 생각해 봅시다.
        문법상 배열의 이름은(arr) 첫 번째 원소의 주소값으로 변환이 될 수 있어야 합니다.
        이 때문에 arr[1]과 같은 문장이*(arr+1)로 바뀌어서 처리될 수 있기 때문이죠.
         
          그런데 "주소값이 존재 한다라는 의미는 해당 원소가 메모리 상에서 존재한다." 라는 의미와 같습니다.
        하지만 레퍼런스는 특별한 경우가 아닌 이상 메모리 상에서 공간을 차지 하지 않습니다.
        따라서 이러한 모습 때문에 레퍼런스들의 배열을 정의하는 것은 언어 차원에서 금지가 되어 있는 것 입니다.
    
    */
    // int& arr[2] = { a,b }; - ERROR!!

    // 반대로 배열들의 레퍼런스는 가능 합니다.
    
    int arr[3] = { 1,2,3 };
    int(&ref)[3] = arr;

    ref[0] = 2;
    ref[1] = 3;
    ref[2] = 1;

    std::cout << arr[0] << arr[1] << arr[2] << std::endl;

    return 0;
}
