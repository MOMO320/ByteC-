#include <iostream>

// 참조자와 포인터는 상당히 유사한 개념입니다. 
// 포인터 역시 다른 어떤 변수의 주소값을 보관함으로써 해당 변수에
// 간접적으로 연산을 수행할 수 있기 때문이죠.
// 하지만 레퍼런스와 포인터는 몇 가지 중요한 차이점이 있습니다.

/*================== 레퍼런스와 포인터의 차이점 ======================

	1. 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 합니다.
		- int& another_a;  (X)  <- 레퍼런스는 정의 시에 반드시 누구의 별명인지 명시 해야 합니다.
		- int* p; (O)  <- 반면 포인터의 경우 전혀 문제가 되지 않습니다.

	2. 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.
	: 레퍼런스의 또 한가지 중요한 특징으로 한 번 어떤 변수의 참조자가 되버린다면, 
	  더 이상 다른 변수를 참조할 수 없게 됩니다.

	   int a = 10;
	   int &another_a = a;	(another_a는 이제 a의 참조자)

	   int b = 3;
	   another_a = b;  (???) 
	   
	   ㅁ 반면에 포인터는 다른 별명이 될 수 있습니다. 

	   int a = 10;
	   int * p = &a;	// p는 a를 가리킨다.

	   int b = 3;
	   p = &b;			// 이제 p는 a를 버리고 b를 가리킨다.


	3. 레퍼런스는 메모리 상에 존재하지 않을 수 도 있다.
    : 포인터의 경우를 생각해봅시다. 우리가 아래와 같이 포인터 p를 정의 한다면

	 - int a = 10;
	 - int* p = &a;	(p는 메모리 상에서 당당히 8 바이트를 차지하게 됩니다.

	 p는 당당히 메모리 상에서 8 바이트를 차지하는 녀석이 됩니다.
	 (물론 32비트 시스텐에서는 4바이트)

	 레퍼런스의 경우를 생각해 봅시다.

	 - int a = 10;
	 - int &another_a = a; (another_a 가 자리를 차지할 필요가 있을까요?)

	 만일 내가 컴파일러라면 another_a 를 위해서 메모리 상에 공간을 할당할 필요가 있을까요?
	 아닙니다. 왜냐하면 another_a 가 쓰이는 자리는 모두 a로 바꿔치기 하면 되니까요.
	 따라서 이 경우 레퍼런스는 메모리상에 존재하지 않게 됩니다.
	 물론 그렇다고 해서 항상 존재하지 않는 것은 아닙니다.

*/


int main2()
{
	int a = 3;
	// int형 변수의 참조자를 만들고 싶을 때에는 int&를 , double 의 참조자를 만드려면
	// double& 로 하면 됩니다.
	// 심지어 int* 와 같은 포인터 타입의 참조자를 만드려면 int*&로 쓰면 됩니다.

	// 아래와 같이 선언하면 : 우리는 another_a는 a의 참조자다! - 라고 선언한것
	// another_a는 a의 또다른 이름 이라고 컴파일러에게 알려주는 것입니다.
	// 따라서 another_a에 어떠한 작업을 수행하든 이는 사실상 a에 그 작업을 하는 것과 마찬가지 입니다.
	int& another_a = a;

	another_a = 5;

	std::cout << "a : " << a << std::endl;
	std::cout << "another_a : " << another_a << std::endl;

	// 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.
	int A = 10;
	int& another_A = A;  // another_a는 이제 a의 참조자

	int b = 3;

	//&another_A = b;
	//another_A = b; // error : 'a' 재정의, 여러 번 초기화 했습니다.
	std::cout << "another_A : " << another_A << std::endl;

	// 포인터는 다른 이의 별명이 될 수 있습니다.
	// 아래와 같이 누구를 가리키는지 자유롭게 할 수 있다.
	int y = 10;
	int* p = &y;	// p는 y를 가리킨다.

	int x = 3;
	p = &x;			// p는 y를 버리고 x를 가리킨다.

	return 0;
}